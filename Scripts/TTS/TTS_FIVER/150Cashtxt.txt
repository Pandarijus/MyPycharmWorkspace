Grid

Beschreibung:
Damit die Komponenten für die Straße gleichmäßig platziert werden können, musste eine Grid-Klasse erstellt werden. Diese Klasse baut auf einem 2-Dimensionalen-Array auf und erweitert dessen Funktion. Durch die Erweiterung ist man nun in der Lage, Straßenkomponenten mit einem Mausklick zu platzieren und dadurch verschiedene Straßenteile miteinander zu verbinden. 

Vorgehen:

Zu Beginn bestand die Frage, wie man am besten Komponenten an einer genauen und gleichmäßigen Position platziert. Nach einiger Recherche wurde ein YouTube Tutorial von CodeMonkey gefunden in dem er ausführlich erklärte, wie man eine Grid-Klasse erstellen kann. Als ersten Schritt galt es geeignete Attribute für das Grid festzulegen. Das erste und wichtigste Attribut ist das 2-Dimensionalen-Integer-Array, da das ganze Grid auf ihm aufbaut. Wie der sein schon sagt, hat das Array 2 Dimensionen, also eine x und y Dimension. Für beide Dimensionen wurde daher ein Attribut erstellt. Das letzte Attribut der Klasse legt die Größe eines Feldes fest. Dadurch konnte die Feldgröße den Komponenten angepasst werden.

Als nächstes galt es über die Methoden der Klasse Grid nachzudenken. Eine wichtige Fähigkeit die, das Grid benötigte, war das Setzen eines Wertes im Grid. Dafür wurde die Methode "SetzeWert" erstellt, die drei Integer als Übergabeparameter besitzt. Die ersten beiden Parameter stehen für die Indizes der 2 Dimensionen des Grids. Der dritte und letzte Parameter steht für den Wert, der in das ausgewählte Feld gesetzt werden soll. Eine If-Anweisung wird in der Methode als erstes ausgeführt, um die Zulässigkeit der Indizes zu überprüfen. Fälle die Unzulässig sind, wären beispielsweise negative Werte, da bei einem Array nur positive Werte zugelassen sind. Zusätzlich wird in der If-Anweisung überprüft, ob versucht wird die Länge des Arrays zu überschreiten. Ohne diese Sicherung kann es schnell zu Fehlern während der Ausführung des Programms kommen. Wenn alle Unzulässigen Indizes ignoriert wurden, wird der Wert direkt in das 2-Dimensionalen-Integer-Array namens gridArray gespeichert.
 

Eine weitere Essenzielle Methode des Grids ist das Unterprogramm namens FeldIndexZuWeltPostition. Es ermöglicht dem Programm Indizes des Grids in Weltpositionen umzuwandeln, welche man dadurch in der Unity Umgebung nutzen kann. Sie erhält beide Indizes als Übergabeparameter und liefert einen Vector3 zurück. Da die Feldgröße als Faktor der einzige Unterschied zwischen der Gridposition und der Weltposition ist, muss man ihn zu der Gridposition multiplizieren, um die Weltposition zu erhalten.

Eine Funktion die sich nachher als wichtig herausgestellt hat, war die Möglichkeit eine Weltpositon in eine Gridposition umwandeln zu können. Dies wurde erreicht mit der Methode BekommeFeldIndexInDerNähe. Wieder ist der differentielle Faktor zwischen Welt- und Grid-Position die Feldgröße. Dadurch dass der Umwandlung der Positionen in die andere Richtung geht, muss man mit dem Kehrwert des Faktors multiplizieren. Als Ergebnis ergibt sich eine Dezimalzahl, da Weltpositionen floats sind, daher muss eine Mathematische Bibliothek genutzt werden, um die Kommazahl in einen Integer wandeln. Dazu wird eine Funktion namens FloorToInt genutzt, um die Nachkommastellen abzuschneiden. Beispielsweise wurde der Wert 1,3 zu 1 gewandelt, aber auch 1,9. Dieser Vorgang wird für die x- und y-Dimension wiederholt und letztendlich als Vector3 zurückgegeben.
 
BekommeFeldPositionInDerNähe ist eine weitere Methode des Grids. Sie benötigt die Feldindizes der Weltposition und wandelt diese, dann wieder in eine Weltposiotion um. Damit die Mitte des Feldes als Weltposition zurückgegeben wird, muss ein Vector3 mit der x- und z-Dimension mit einem Wert von der Hälfte der Feldgröße addiert werden. Das lässt sich anhand der Abbildung XXX erklären. Ein Feld ist ein Quadrat, und um von der linken Ecke des Quadrats zu kommen muss man die Hälfte der Breite nach rechts gehen und die Hälfte der Höhe nach oben gehen.  

Als letzter Schritt war die Erstellung des Konstruktors. In dem Konstruktor werden alle Attribute initialisiert. Zusätzlich gibt es die Möglichkeit durch einen booleschen Übergabeparameter namens "showGrid" das Grid zu visualisieren. Wenn "showGrid" wahr ist (true), dann wird die Funktion "ShowGrid" aufgerufen. Diese beinhaltet einen Integer namens "count" der in einer zweifachen For-Schleife hochgezählt wird. Die zwei Schleifen zählen so lange bis sie einmal das ganze Grid durchlaufen haben. Bei jedem Schritt wird der hochgezählte Wert an der jetzigen Stelle im Grid gespeichert. Dies wird ermöglicht durch die zuvor angesprochene "SetzeWert" Methode, die nur Werte speichert, wenn diese sich an einer zulässigen Position befinden. Nachdem das Programm den Wert in das Grid gespeichert, wird mit Hilfe der statischen Klasse UtillsClass ein Text erstellt, der in der Mitte des Feldes positioniert wird. Direkt danach wird mit dem Befehl "Debug.DrawLine" zwei Linien erstellt, die man im Editor sehen kann. Diese Linien zeigen die Unterseite und die linke Seite des quadratförmigen Feldes. Sobald jedes Feld des Grids einmal durchlaufen wurde, entstehen noch zwei lange Linien, die die Oberseite und rechte Seite des Grids füllen und es somit vervollständigen. Jedes Feld hat nun eine eindeutig zugewiesene Identifikationsnummer. Dadurch wurde die Funktionsfähigkeit des Grids überprüft (Abbildung XXX). Letztendlich wird diese Ansicht in dieser Simulation nicht gezeigt.  
 
 
Benutzerdefinierte Platzierung der Komponente
Schlüsselwort "public" verwendet. Durch die Nutzung des Schlüsselworts, ist es möglich die Werte, der Variablen im Unity-Editor anzupassen. Dadurch wird ist man in der Lage schnell und einfach unerwünschte Werte anzupassen.

Zu Beginn des Programms, wird das Gird-Objekt in der "Start" Methode mit den gewählten Attributen initialisiert.
  

In der "Update" Methode, die mehrmals pro Sekunde aufgerufen wird, befindet sich die wichtigste Logik der Komponentenplazierung. Mit einem If-Statement wird überprüft, ob die linke Maustaste gedrückt wird. Trift die Aussage zu wird wiederum überprüft, ob die Maus auf ein Teil der Nutzeroberfläche zeigt. Der Folgende Code wird nur ausgeführt, wenn dies nicht der Fall ist. Wenn das Programm ungehindert bis hier gekommen ist, wird ein sogenannter Ray erstellt. Dieser Ray hat die Kamera als Startpunkt und wird in die Richtung der Maus geworfen. 

Trifft dieses Ray eine Unity-Collider-Komponente wird ein "RaycastHit" Objekt zurückgegeben welches sämtliche Informationen über das getroffene Objekt besitzt. Eine dieser Informationen ist die Position des Schnittpunkts zwischen dem Ray und dem Collider. Diesen Schnittpunkt kann als Übergabeparameter in die Methode "BekommeFeldIndexInDerNähe" des Grids geben, um die Indizes des am nächsten Feldes zu bestimmen. Mit diesen Indizes und der Methode "FeldIstFrei" kann man prüfen, ob das ausgewählte Feld für die Platzierung frei ist. Wenn ein Feld besetzt ist, wird es auf 1 gesetzt und wenn es frei ist bleibt es auf 0. Daher wird mit einem booleschen Ausdruck überprüft, ob die Position des Grids 0 ist. Umrundet ist dieser Ausdruck mit einer Try-Catch-Struktur. Diese ist dafür da, um Ausnahmefälle abzufangen, falls ungültige Werte übergeben werden. Ist dies der Fall würde es normalerweise zu einem Runtime-Error kommen. Dieser wird, nun jedoch abgefangen und statt einem Error wird die Aussauge false zurückgegeben. Das bedeutet, dass bei ungültigen Werten, das Feld als besetzt angezeigt wird. 
 
Wird bei der Methode "FeldIstFrei" true zurückgegeben wird als nächstes überprüft, ob das getroffene Objekt der Boden ist. Dem Boden wurde ein "Tag" gegebenen welches verschieden Objekte unterteilt. Dadurch, dass nur der Boden dieses Tag zugewiesen bekommen hat, können man es durch das "Tag" eindeutig identifizieren. Dafür kann man die von Unity bereitgestellte Funktion "CompareTag" nutzen, die Tags vergleicht. Aufgrund dieser Funktion kann man nun feststellen, ob das vom Ray getroffene Objekt der Boden ist.    
 


Für den Fall, dass das Feld frei ist und der Boden vom Ray getroffen wurde, wird das Feld des Gird besetzt. Danach wird mit den Feldindizes als Übergabeparameter der "FeldIndexZuWeltPostition" Methode eine Weltposition generiert. Diese Position wird nun verwendet, um die Komponenten zu platzieren. Für die Auswahl des auszuführenden Codes wird eine Reihe von If-Else-Anweisungen verwendet, die den Wert des Dropdown-Menus überprüfen. Wenn dieser Wert 0 ist, bedeute es, dass keine Komponente ausgewählt wurde. Aufgrund dessen wird dieser Fall mit dem "return" Befehl abgebrochen. Bei einem Wert zwischen 1 und 15 wird eines der Komponenten ausgewählt und erstellt. Mit der Unity-Funktion "Instantiate" wird dies ermöglicht. Als Übergabeparameter für diese Funktion wird jeweils ein “GameObjekt” benötigt, eine Position und eine Rotation. Abschließend wird das erzeugte Objekt in das Attribut "ErzeugtesElement" zwischengespeichert, bis ein neues Objekt erzeugt wird. Zusätzlich wird außerdem von dem Objekt abhängig die Variable "DrehIndex" entweder auf 0 oder 1 gesetzt abhängig von der Achse, um die die Komponente gedreht werden darf. Dieser "DrehIndex" wird schlussendlich an das Ende des Namens des Objektes gehängt, damit man nachher einfachen Zugriff auf den Index hat.

Für den Fall, dass das Feld entweder besetzt ist oder und der getroffene Collider nicht zum Boden gehört wird ein anderer Code ausgeführt. In diesem Fall handelt es sich bei dem getroffene Collider bei einem bereits platzierten Objekt. Dieses Objekt wird deshalb in die Variable "ErzeugtesElement" gespeichert. Als nächster Schritt wird der “DrehIndex” extrahiert von dem Namen des Objektes. Dazu wird einfach der letzte Buchstabe des namens genommen und in einen Integer umgewandelt;
 

